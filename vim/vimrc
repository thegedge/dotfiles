"---------------------------------------------------------------------
" Gedge's .vimrc
"---------------------------------------------------------------------
set nocompatible   " use vim defaults, not vi defaults
if !exists("vimpager")
  let mapleader=" "  " space bar for leader
endif

"---------------------------------------------------------------------
" Plugins
"---------------------------------------------------------------------
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'gmarik/Vundle.vim'

" Coloring
Plugin 'flazz/vim-colorschemes'
Plugin 'Yggdroot/indentLine'

" Plugins for syntax and completion
Plugin 'cakebaker/scss-syntax.vim'
Plugin 'ebfe/vim-racer'
Plugin 'fatih/vim-go'
Plugin 'peterhoeg/vim-qml'
Plugin 'scrooloose/syntastic'
Plugin 'tpope/vim-markdown'
Plugin 'vim-scripts/gcov.vim'
Plugin 'vim-scripts/swig-syntax'
Plugin 'wting/rust.vim'
Plugin 'powerman/vim-plugin-AnsiEsc'
Plugin 'hashivim/vim-terraform'

" Code/markup commenting shortcuts
Plugin 'scrooloose/nerdcommenter'
" Magical tabbing
"Plugin 'ervandew/supertab'
" Table-based manipulations
Plugin 'godlygeek/tabular'
" Text object for function arguments (a, and i,)
Plugin 'PeterRincker/vim-argumentative'
" Additional character info (e.g., html entity, unicode name)
Plugin 'tpope/vim-characterize'
" Git support
Plugin 'tpope/vim-fugitive'
" Repeat plugin commands with .
Plugin 'tpope/vim-repeat'
" Manipulate surroundings
Plugin 'tpope/vim-surround'
" Fuzzy path matching
Plugin 'kien/ctrlp.vim'
" Fuzzy completion while typing
Plugin 'Valloric/YouCompleteMe'
" Silver searcher (ag) integration
Plugin 'rking/ag.vim'

call vundle#end()

"---------------------------------------------------------------------
" Syntax coloring
"---------------------------------------------------------------------

if &t_Co >= 256 || has("gui_running")
  let g:gruvbox_italic = 0
  let g:gruvbox_contrast_dark = "hard"
  let g:gruvbox_contrast_light = "medium"
  let g:gruvbox_invert_tabline = 1
  colorscheme gruvbox
elseif &t_Co > 1
  colorscheme desert
endif

if &t_Co > 1
  syntax enable
endif

" Enable filetype-specific indenting and plugins
filetype plugin indent on

"---------------------------------------------------------------------
" Basic configuration
"---------------------------------------------------------------------
set nowrap           " no line wrapping
set ruler            " ruler
set number           " line numbering
set showmatch        " show matching brackets
set mouse=           " disable mouse
set pastetoggle=<F2> " F2 for paste mode
set hidden           " buffers are hidden instead of closed
set showtabline=2    " always show tab bar at top
set laststatus=2     " always show status line
set history=1000     " remember more commands
set autowrite        " write on make/shell commands
set undolevels=1000  " max number of changes to remember
set visualbell       " no beeps
set noerrorbells     " no beeps
set confirm          " confirm changes before closing buffers
set splitright       " vertical splits on the right
set autoindent       " automatic indentation
set background=dark

" Autocompletion when typing commands shows options above instead of inline
set wildmenu
set wildmode=full

" Files to ignore when expanding wildcards
set wildignore=*.swp,*.bak,*.pyc,*.class,*.o

" Whitespace behaviour
set noexpandtab      " I like <Tab>s more than spaces
set tabstop=4        " number of spaces a <Tab> character equals
set softtabstop=4    " number of spaces a <Tab> character equals (insert mode)
set shiftwidth=4     " number of spaces to use for indenting
set smartindent      " smart autoindent on new lines
set smarttab         " smart <Tab> behaviour at start of line
set copyindent       " copy indent structure when making new lines
set backspace=indent,eol,start

" Non-printable characters
set nolist           " don't show non-printable characters
let &listchars="eol:\u00B7,tab:\u25B9\ "

" Fill characters
let &fillchars="vert:\u2577,fold:\u254C"

" Dictionary for CTRL+P and CTRL+N auto-completion
set dictionary=~/.ispell_english,/usr/share/dict/words
set complete=.,w,k
set keywordprg=dict

" So find looks in the current directory tree
set path+=./**

" Backups, swaps, and temps
set nobackup
set noswapfile
set directory=~/.vim/tmp,/var/tmp,/tmp

" Remember cursor position for files
set viminfo='10,\"100,:20,%,n~/.vim/.viminfo

" Set title in terminal window
set titlestring=%t%(\ %M%)%(\ (%{expand(\"%:p:h\")})%)%(\ %a%)
if &term == "screen"
  set t_ts=k
  set t_fs=\
endif
if &term == "screen" || &term =~? "^xterm"
  set title
endif

"set omnifunc=syntaxcomplete#Complete

"---------------------------------------------------------------------
" Status Line
"--------------------------------------------------------------------
function! FugitiveLine()
  let out = ''
  let has_fugitive = (exists('g:loaded_fugitive') && g:loaded_fugitive == 1)
  if l:has_fugitive
    let out = " \u2442 " . fugitive#head() . ' '
  endif
  return out
endfunction

function! CharDescription()
  let c = matchstr(getline('.')[col('.') - 1:-1], '.')
  let nr = (c ==# "\n" ? 0 : char2nr(c))

  let has_characterize = (exists('g:loaded_characterize') && g:loaded_characterize == 1)
  if l:has_characterize
    let out = '<' . characterize#description(nr, 'unknown')
    let entity = characterize#html_entity(nr)
    if !empty(entity)
      let out .= ', ' . entity
    endif
    let out .= '> ' . printf('U+%04X', nr)
  else
    let out = printf('U+%04X', nr)
  endif

  return out
endfunction

let &statusline=""
"let &statusline.="%2*\ \ %t\ \ "                             " tail of the filename
let &statusline.="%1*\ \ %{strlen(&fenc)?&fenc:'none'}"      " file encoding
let &statusline.="\ \u00B7\ %{&ff}"                          " file format
let &statusline.="\ \u00B7\ %{strlen(&ft)?&ft:'<unknown>'}"  " file type
let &statusline.="%h"                                        " help file flag
let &statusline.="%m"                                        " modified flag
let &statusline.="%r"                                        " read only flag
let &statusline.="\ \ "
let &statusline.="%0*%{FugitiveLine()}"                      " git branch
let &statusline.="%="                                        " left/right separator
let &statusline.="%{CharDescription()}\ "                    " char under cursor
let &statusline.="%4*\ l\ %1*%5l/%-5L\ "                     " cursor line/total lines
let &statusline.="%5*\ c\ %2*%3c-%-3v\ "                     " cursor column/virtual column
let &statusline.="%3*\ \ %P\ \ "                             " percent through file

hi User1 term=bold,reverse cterm=bold,reverse ctermfg=235 ctermbg=253
hi User2 term=bold,reverse cterm=bold,reverse ctermfg=234 ctermbg=253
hi User3 term=bold,reverse cterm=bold,reverse ctermfg=233 ctermbg=253
hi User4 term=bold,reverse cterm=bold,reverse ctermfg=235 ctermbg=241
hi User5 term=bold,reverse cterm=bold,reverse ctermfg=234 ctermbg=241

"---------------------------------------------------------------------
" Search
"--------------------------------------------------------------------
set incsearch      " show matches as typing
set ignorecase     " ignore case when searching
set smartcase      " ignore case only if search pattern completely lowercase
set hlsearch       " highlight search terms
set magic          " how backslashes are interpreted in searches

" Remove highlight from searches (normal mode)
nmap <Silent> <Leader>/ :nohlsearch<CR>

" n/N will move to the next/previous result and center line on screen
nnoremap n nzz
nnoremap N Nzz

"---------------------------------------------------------------------
" Folds
"---------------------------------------------------------------------
set foldmethod=indent     " folding on indentation
set foldlevel=100         " 'disable' folding at first

" Space increases fold level, if possible, otherwise behaves as normal
nnoremap <Silent> <Leader><Space> @=(foldlevel('.') ? 'za' : "\<Space>")<CR>
nnoremap + zr    " + reduces fold level across buffer
nnoremap - zm    " - increases fold level across buffer

"---------------------------------------------------------------------
" Filetype specifics
"---------------------------------------------------------------------
if has("autocmd")
  function! RestoreCursor()
    if line("'\"") <= line("$")
      normal! g`"
      return 1
    endif
  endfunction

  augroup restore_cursor
    autocmd!
    au BufReadPost * call RestoreCursor()
  augroup END

  " TODO specify :set options by using a dictionary mapping here
  let s:sources = [
  \   'c', 'cpp', 'css', 'go', 'html', 'java', 'javascript', 'python',
  \   'ruby', 'rust', 'terraform', 'vim'
  \ ]

  function! SourceFileAutoCommands()
    if index(s:sources, &ft) != -1
      " Highlight extra whitespace at the end of a line
      hi ExtraWhitespace ctermbg=red guibg=red
      match ExtraWhitespace /\s\+$/

      " Color column at 80 characters for soft limit, 100+ for hard limit
      let columns = '80,'.join(range(100, 1000), ',')
      execute 'set colorcolumn=' . columns

      " Improve source code indenting
      "   (0 - with unclosed parentheses, line up in front of open paren
      set cindent
      set cino='(0'
    endif
  endfunction

  augroup all_source
    autocmd!
    au BufNewFile,BufRead * call SourceFileAutoCommands()
  augroup END
endif

"---------------------------------------------------------------------
" Windows and tabs
"---------------------------------------------------------------------
set winminwidth=0   " Windows can have zero width
set winminheight=0  " Windows can have zero height

" Leader-based window commands
nmap <Leader><Left>  :wincmd h<CR>
nmap <Leader><Down>  :wincmd j<CR>
nmap <Leader><Up>    :wincmd k<CR>
nmap <Leader><Right> :wincmd l<CR>
nmap <Leader>_       :wincmd _<CR>
nmap <Leader>\|      :wincmd \|<CR>
nmap <Leader>=       :wincmd =<CR>

" Tab commands with leader keys
nmap <Leader>+       :tabnew<CR>
nmap <Leader>-       :tabc<CR>
nmap <Leader>>       :tabn<CR>
nmap <Leader><       :tabp<CR>

"---------------------------------------------------------------------
" Miscellanouse key mappings and such
"---------------------------------------------------------------------

" typing a semi-colon starts command (normal mode)
nnoremap ; :

" Q reflows paragraph (normal and visual mode)
nnoremap Q gqap
vnoremap Q gq

" Tab toggles hidden characters (normal mode)
nnoremap <Tab> :let &background = ( &background == "dark"? "light" : "dark" )<CR>

" Reloads a file
nnoremap <C-E> :edit<CR>

" Remapping for next/previous file (normal mode)
nnoremap <C-N> :next<CR>
nnoremap <C-P> :prev<CR>

" Simpify working with my vimrc
nnoremap <Leader>ev :edit $MYVIMRC<CR>
nnoremap <Leader>sv :source $MYVIMRC<CR>

"---------------------------------------------------------------------
" Other plugin config
"---------------------------------------------------------------------

" Sueprtab configuration
let g:SuperTabDefaultCompletionType = "context"

" netrw preview in vertical splits, equal size, wide list style
let g:netrw_preview = 1
let g:netrw_winsize = 0
let g:netrw_liststyle = 3

" Session.vim configuration
let g:session_autoload='yes'
let g:session_autosave='yes'
let g:session_default_to_last=1

" Syntastic defaults to passive mode
let g:syntastic_mode_map = {'mode': 'passive'}

" Indent guides
let g:indentLine_char = '┆'
let g:indentLine_first_char = '┆'
let g:indentLine_showFirstIndentLevel = 1
let g:indentLine_fileTypeExclude = ['help', 'man']

" YouCompleteMe configuration
let g:ycm_auto_trigger = 1
let g:ycm_complete_in_comments = 1
let g:ycm_collect_identifiers_from_comments_and_strings = 1
let g:ycm_seed_identifiers_with_syntax = 1
let g:ycm_autoclose_preview_window_after_completion = 1

" CtrlP configuration
let g:ctrlp_match_window = 'max:25'
let g:ctrlp_custom_ignore = {
      \   'dir':  '\v[\/](\.(git|hg|svn))|Godeps|target|_site|tmp|vendor$',
      \ }

" Don't have a passthrough for vimpager
let vimpager_passthrough = 0
